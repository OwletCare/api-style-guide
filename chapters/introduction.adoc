[[introduction]]
= Introduction

API's following this guide provide functionality via RESTful APIs with a JSON
payload. Engineering teams own, deploy and operate these microservices. APIs
most express what our systems do. API's are to be designed with
high-quality and a long-lasting mindset.

"API First" is a key
engineering principle in regards to API's. Microservice development begins with
API's
defined outside the code and involves peer-review
feedback to achieve high-quality APIs. API First encompasses a set of
quality-related standards and fosters a peer review culture including a
lightweight review procedure. When done this way API's are:

* Easy to understand and learn
* General and abstracted from specific implementation and use cases
* Robust and easy to use
* Have a common look and feel
* Follow consistent RESTful style and syntax
* Consistent with other teams’ APIs and global architecture

Ideally, APIs will look like the same author created them.


[[conventions-used-in-these-guidelines]]
== Conventions used in these guidelines

The requirement level keywords "MUST", "MUST NOT", "SHOULD", "SHOULD NOT", "MAY"
used in this document (case insensitive) are to be
interpreted as described in https://www.ietf.org/rfc/rfc2119.txt[RFC
2119].
In case guidelines are changing, following rules apply:

* Existing APIs if updated can be versioned for a new update
* New APIs have to respect the current guidelines
* Clients of existing APIs will expect no change to API functionality

API's that becomes public,
externally available, should be re-reviewed and changed according to
current guidelines - for sake of overall consistency.

[[api-design-principles]]
== API design principles

Apply the RESTful web service principles to all kinds of application
service components, independently from whether they provide
functionality via the internet or intranet.

* Prefer REST-based APIs with JSON payloads
* Prefer systems to be truly RESTful
footnote:fielding-restful[Per definition of R.Fielding REST APIs have to support
HATEOAS (maturity level 3). These guidelines do not strongly advocate for
full REST compliance, but limited hypermedia usage, e.g. for pagination
(see <<hypermedia>>).
However, the term "RESTful API", will be used here, due to the absence
of an alternative established term and to keep it like the majority
of the web service industry that also use the term for their REST
approximations — in fact, in today's industry full HATEOAS compliant
APIs are a very rare exception.]

An important principle for API design and usage is Postel's
Law, aka http://en.wikipedia.org/wiki/Robustness_principle[The
Robustness Principle] (see also https://tools.ietf.org/html/rfc1122[RFC 1122]):

* Be liberal in what you accept, be conservative in what you send

_Readings:_ Some interesting reads on the RESTful API design style and service
architecture:

* Article:
https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling[REST API Design - Resource Modeling]
* Article:
https://martinfowler.com/articles/richardsonMaturityModel.html[Richardson Maturity Model -- Steps toward the glory of REST]
* Book:
https://www.amazon.com/Irresistible-APIs-Designing-that-developers/dp/1617292559/[Irresistible
APIs: Designing web APIs that developers will love]
* Book:
https://www.amazon.com/REST-Practice-Hypermedia-Systems-Architecture/dp/0596805829/[REST
in Practice: Hypermedia and Systems Architecture]
* Book: https://leanpub.com/build-apis-you-wont-hate[Build APIs You
Won't Hate]
* Fielding Dissertation:
http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm[Architectural
Styles and the Design of Network-Based Software Architectures]


[[api-first]]
== API first

API First requires two aspects:

* Define APIs first, before coding its implementation, using a standard
specification language
* Get early review feedback from peers and client developers

Defining APIs outside the code:

* Facilitate early review feedback.
* Allows a good understanding of the domain and required functionality.
* Allows generalized resources.
    ** i.e. Use case specific APIs are avoided.
* Allows a clear separation of WHAT vs. HOW concerns.
    ** i.e. Abstraction from implementation aspects. APIs should be stable even if we replace complete service implementation including its underlying technology stack.

API definitions with standardized specification format also facilitate:

* Single source of truth for the API specification. It is a crucial part
of a contract between service provider and client users.
* Infrastructure tooling for API discovery, API GUIs, API documents,
automated quality checks

Peer review is important to get high
quality APIs, enable architectural and design alignment, and
support development of client applications decoupled from API development.
